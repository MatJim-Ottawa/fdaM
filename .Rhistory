'gamma' =
{
#  Note  Ymat must contain only positive numbers
if (any(Ymat <= 0))
{
stop('DISTR is gamma and Y contains nonpositive values')
}
devFn   = function(mu,Ymat) 2*(-log(Ymat/mu) + (Ymat - mu)/mu)
stdFn   = function(mu) mu
linkFn  = function(mu)  1./mu
DlinkFn = function(mu) -1./mu.^2
loBnd   = eps
upBnd   = 1/loBnd
IlinkFn = function(eta) 1./constrain(eta,loBnd,upBnd)
mu      = max(Ymat, eps)
},
'inverse gaussian'=
{
#  Note  Ymat must contain only positive numbers
if (any(any(Ymat <= 0)))
{
error('DISTR is inverse gaussian and Y contains nonpositive values')
}
devFn   = function(mu,Ymat) ((Ymat - mu)/mu)^2/ Ymat
stdFn   = function(mu)  mu.^(3/2)
loBnd   = eps^(1/2)
upBnd   = 1/loBnd
linkFn  = function(mu) constrain(mu,loBnd,upBnd)^(-2)
DlinkFn = function(mu)  -2*mu^(-3)
IlinkFn = function(eta) constrain(eta,loBnd,upBnd)^(-1/2)
mu      = Ymat
},
stop('Distribution name is invalid.')
)
}
# else if iscell(distr) && length(distr) == N
#     #  --------------------------------------------------------------------
#     #    Observations can be in different families, distr is a cell array.
#     #  --------------------------------------------------------------------
#     mu      = zeros(N,1)
#     loBnd   = zeros(N,1)
#     upBnd   = zeros(N,1)
#     devFn   = cell(N,1)
#     stdFn   = cell(N,1)
#     linkFn  = cell(N,1)
#     DlinkFn = cell(N,1)
#     IlinkFn = cell(N,1)
#     #  Dealing with the presence of some binomial observations Ymat has
#     #  to be a cell with N rows and 2 columns for all data.  Ugh!
#     binomwrd = iscell(Ymat) && all(size(Ymat) == [N,2])
#     for i=1N
#         distri = distr{i}
#         if ~ischar(distri)
#             error('A distribution specification is not a string.')
#         end
#         switch distri
#             case 'normal'
#                 #  Note  Ymat can be any real number, no restrictions
#                 devFn{i}   = @(mu,Ymat) (Ymat - mu).^2
#                 stdFn{i}   = @(mu)  ones(size(mu))
#                 linkFn{i}  = @(mu)  mu
#                 DlinkFn{i} = @(mu)  ones(size(mu))
#                 IlinkFn{i} = @(eta) eta
#                 mu(i,) = Ymat(i,)
#             case 'binomial'
#                 if all(isnumeric(Ymat(i,)))
#                     #  If YMAT a matrix, M is taken to be 1 (set below)
#                     #  and it must be a binary matrix containing only
#                     #0's and 1's
#                     if any(Ymat(i,) < 0 | Ymat(i,) > 1)
#                         error(['For binomial case, YMAT a single column but ', ...
#                             ' contains values other than 0 or 1.'])
#                     end
#                 elseif binomwrd
#                     Freqi = Ymat{i,1}
#                     Mi    = Ymat{i,2}
#                     if length(Mi) == 1
#                         Mi = Mi*ones(1,ncurve)
#                     end
#                     if ~all(size(Mi) == size(Freqi))
#                         error(['DISTR is binomial and matrix M is not the same ', ...
#                             'size as matrix FREQ'])
#                     end
#                     if any(any(Mi < 0))
#                         error(['DISTR is binomial and one or more values in M ', ...
#                             'have nonpositive values'])
#                     end
#                     if any(any(floor(Mi) ~= Mi))
#                         error(['DISTR is binomial and one or more values in M ', ...
#                             'have noninteger values.'])
#                     end
#                     #  Redefine YMAT is the proportion of sucesses
#                     Ymat(i,) = (Freqi./Mi)
#                 else
#                     error(['DISTR is binomial and YMAT has incorrect dimensions ', ...
#                         ' or is of wrong type.'])
#                 end
#                 devFn{i}   = @(mu,Ymat) 2*M.*(Ymat.*log((Ymat+(Ymat==0))./mu) + ...
#                     (1-Ymat).*log((1-Ymat+(Ymat==1))./(1-mu)))
#                 stdFn{i}   = @(mu)  sqrt(mu.*(1-mu)./M)
#                 linkFn{i}  = @(mu)  log(mu./(1-mu))
#                 DlinkFn{i} = @(mu)  1./(mu.*(1-mu))
#                 loBnd(i)   = log(eps)
#                 upBnd(i)   = -loBnd(i)
#                 IlinkFn{i} = @(eta) 1./(1 + exp(-constrain(eta,loBnd,upBnd)))
#                 mu(i)      = (M(i).*Ymat(i) + 0.5)./(M(i) + 1)
#             case 'poisson'
#                 #  Note Ymat must not contain negative numbers
#                 if any(Ymat(i,) < 0)
#                     error('DISTR is poisson and YMAT contains negative values')
#                 end
#                 devFn{i}   = @(mu,Ymat) 2*(Ymat.*(log((Ymat+(Ymat==0))./mu)) - ...
#                     (Ymat - mu))
#                 stdFn{i}   = @(mu)  sqrt(mu)
#                 linkFn{i}  = @(mu)  log(mu)
#                 DlinkFn{i} = @(mu)  1./mu
#                 loBnd(i)   = log(eps)
#                 upBnd(i)   = -loBnd(i)
#                 IlinkFn{i} = @(eta) exp(constrain(eta,loBnd,upBnd))
#                 mu(i,)    = Ymat(i,) + 0.25
#             case 'gamma'
#                 #  Note  Ymat must contain only positive numbers
#                 if any(Ymat(i) <= 0)
#                     error('DISTR is gamma and Y contains nonpositive values')
#                 end
#                 devFn{i}   = @(mu,Ymat) 2*(-log(Ymat./mu) + (Ymat - mu)./mu)
#                 stdFn{i}   = @(mu) mu
#                 linkFn{i}  = @(mu)  1./mu
#                 DlinkFn{i} = @(mu) -1./mu.^2
#                 loBnd(i)   = eps
#                 upBnd(i)   = 1/loBnd(i)
#                 IlinkFn{i} = @(eta) 1./constrain(eta,loBnd,upBnd)
#                 mu(i,)    = max(Ymat(i,), eps)
#             case 'inverse gaussian'
#                 #  Note  Ymat must contain only positive numbers
#                 if any(Ymat(i,) <= 0)
#                     error(['DISTR is inverse gaussian and Y contains ', ...
#                         'nonpositive values'])
#                 end
#                 devFn{i}   = @(mu,Ymat) ((Ymat - mu)./mu).^2./ Ymat
#                 stdFn{i}   = @(mu)  mu.^(3/2)
#                 loBnd(i)   = eps.^(1/2)
#                 upBnd(i)   = 1/loBnd(i)
#                 linkFn{i}  = @(mu)  constrain(mu,loBnd,upBnd).^(-2)
#                 DlinkFn{i} = @(mu)  -2*mu.^(-3)
#                 IlinkFn{i} = @(eta) constrain(eta,loBnd,upBnd).^(-1/2)
#                 mu(i,)    = Ymat(i,)
#             otherwise
#                 error('Distribution name is invalid.')
#         end
#     end
else
{
stop('DISTR is neither a string or a cell array of length N.')
}
#--------------------------------------------------------------------------
#                   Initialize mu and eta from Ymat.
#--------------------------------------------------------------------------
# compute eta = E(y) from mu
if (is.character(distr))
{
eta = linkFn(mu)
}
# else
#     {
#       eta  = matrix(0,N,nurve)
#       Deta = matrix(0,N,nurve)
#       stdm = matrix(0,N,nurve)
#       for (i in 1:N)
#           {
#             linkFni  = linkFn{i}
#             eta(i,) = linkFni(mu(i,))
#           }
#
#     }
#--------------------------------------------------------------------------
#                        Set up for iterations
#--------------------------------------------------------------------------
iter     = 0
iterLim  = 100
eps      = 0.1
seps     = sqrt(eps)
convcrit = 1e-6
sqrtwt   = sqrt(Wtvec)
#  set up starting value Bvec0 if required
if (is.null(Bvec0))
{
Bvec0 = matrix(0,nbasis,ncurve)
}
Bvec = Bvec0
# Enforce limits on mu to guard against an inverse linkFn that doesn't map
# into the support of the distribution.
switch(distr,
'binomial' =
{
# mu is a probability, so order one is the natural scale, and eps is a
# reasonable lower limit on that scale (plus it's symmetric).
muLims = c(eps,1-eps)
},
# Here we don't know the natural scale for mu, so make the lower limit
# small.  This choice keeps mu^4 from underflowing.  No upper limit.
'poisson'           = {muLims = realmin.^.25},
'gamma'             = {muLims = realmin.^.25},
'inverse gaussian'  = {muLims = realmin.^.25}
)
#--------------------------------------------------------------------------
#                       Start of GLM iteration loop
#--------------------------------------------------------------------------
while (iter <= iterLim)
{
iter = iter+1
# Compute adjusted dependent variable for least squares fit
if (is.character(distr))
{
Deta = DlinkFn(mu)
stdm = stdFn(mu)
}
#     else
#         {
#           for (i in 1:N)
#             {
#               DlinkFni  = DlinkFn{i}
#               stdFni    = stdFn{i}
#               mui       = mu(i,)
#               Deta(i,) = DlinkFni(mui)
#               stdm(i,) = stdFni(mui)
#             }
#         }
Zvec = eta + (Ymat - mu) * Deta
# Compute IRLS weights the inverse of the variance function
sqrtw = (sqrtwt %*% matrix(1,1,ncurve))/(abs(Deta)*stdm)
# Compute coefficient estimates for this iteration - the IRLS step
Bvec.old   = Bvec
if (!is.null(addterm))
{
Ymattmp = Zvec - addterm
}
else
{
Ymattmp = Zvec
}
Ymatw   = Ymattmp*sqrtw
Xmatw   = Xmat*(sqrtwt*matrix(1,1,nbasis))
if (is.null(lamRmat))
{
Mmat = t(Xmatw)%*%Xmatw
}
else
{
Mmat = t(Xmatw) %*% Xmatw + lamRmat
}
Bvec    = solve(Mmat,(t(Xmatw) %*% Ymatw))
if (!is.null(addterm))
{
eta = Xmat %*% Bvec + addterm
}
else
{
eta = Xmat %*% Bvec
}
if (is.character(distr))
{
mu = IlinkFn(eta)
}
#     else
#         {
#           for (i in 1:N)
#             IlinkFni  = IlinkFn{i}
#             mu(i,) = IlinkFni(eta(i,))
#         }
# Force mean in bounds, in case the linkFn function is faulty
if (is.character(distr))
{
# Hidden function for reusing code
f_ = function()
{
if (any(any(mu < muLims(1))))
{
for (j in 1:m)
{
mu[,j] = max(mu[,j],muLims[1])
}
}
}
switch(distr,
'binomial'=
{
if (any(any(mu < muLims[1] | muLims[2] < mu)))
{
for (j in 1:m)
{
mu[,j] = max(min(mu[,j],muLims[2]),muLims[1])
}
}
},
'poisson' =
{
f_()
},
'gamma' =
{
f_()
},
'inverse gaussian' =
{
f_()
}
)
}
#     else
#       {
#         for (i in 1:N)
#             distri = distr{i}
#             switch distri
#                 case 'binomial'
#                     if any(any(mu(i,) < muLims(1) | muLims(2) < mu(i,)))
#                         for j=1m
#                             mu(i,j) = max(min(mu(i,j),muLims(2)),muLims(1))
#                         end
#                     end
#                 case {'poisson' 'gamma' 'inverse gaussian'}
#                     if any(any(mu(i,) < muLims(1)))
#                         for j=1m
#                             mu(i,j) = max(mu(i,j),muLims(1))
#                         end
#                     end
#             end
#         end
#       }
# Check stopping conditions
if (max(max(abs(Bvec-Bvec.old))) < convcrit*max(max(abs(Bvec.old)))) break
#     pause
}
#--------------------------------------------------------------------------
#                    end of GLM iteration loop
#--------------------------------------------------------------------------
if (iter > iterLim) warning('smooth.GLM:','Iteration ','Iteration limit reached.')
# if (nargout > 1)
#     # Sum components of deviance to get the total deviance.
#     if ischar(distr)
#         di       = devFn(mu,Ymat)
#         Deviance = sum((Wtvec*ones(1,ncurve)).*di)
#     else
#         Deviance = zeros(N,ncurve)
#         for i=1N
#             devFni = devFn{i}
#             di = devFni(mu(i,),Ymat(,i))
#             Deviance(i,) = sum((Wtvec(i)*ones(1,ncurve)).*di)
#         end
#     end
# end
# if nargout > 2
#     stats = []
# end
if (is.character(distr))
{
di = devFn(mu,Ymat)
Deviance = sum((Wtvec %*% matrix(1,1,ncurve)) * di)
}
else
{
for (i in 1:N)
{
devFni  = devFn[i]
di      = devFni(mu[i,],Ymat[,i])
Deviance[i,] = sum((Wtvec[i] %*% matrix(1,1,ncurve)) * di)
}
}
return(list(Bvec = Bvec, Deviance = Deviance))
}
debug(glm.fda)
glmresult = glm.fda(basismat, y, 'normal', lamRmat)
glmresult = glm.fda(basismat, y, 'normal', lamRmat)
Xmatw   = Xmat*(sqrtwt*matrix(1,1,nbasis))
View(sqrtwt)
Xmatw   = Xmat*(sqrtwt %*% matrix(1,1,nbasis))
source('~/MATLAB/Repositories/fdaM/smooth.GLM.R')
source("ycheck.R")
source("argcheck.R")
source("constrain.R")
source("glm.fda.R")
source("smooth.GLM.R")
#  tests for function smooth.GLM
#  ----------------  normal link with no covariates  --------------------
library(pracma)
library(fda)
n       = 101
argvals = linspace(0,2*pi,n)
y0      = sin(2*argvals)
y02     = cos(2*argvals)
sig     = 0.2
y       = y0 + sig * randn(n,1)
y       = cbind(y, y02 + sig * randn(n,1))
basisobj = create.bspline.basis(c(0,2*pi),n+2)
basismat = eval.basis(argvals, basisobj)
Lfdobj = int2Lfd(2)
penmat = eval.penalty(basisobj,Lfdobj)
lambda  = 1e-1
lamRmat = lambda * penmat
glmresult = glm.fda(basismat, y, 'normal', lamRmat)
debugSource('~/MATLAB/Repositories/fdaM/glm.fda.R')
glmresult = glm.fda(basismat, y, 'normal', lamRmat)
Deviance = sum((Wtvec %*% matrix(1,1,ncurve)) * di)
(Wtvec %*% matrix(1, 1, ncurve))
Deviance = sum((Wtvec %*% matrix(1,1,ncurve)) %*% di)
di
di = devFn(mu,Ymat)
di
mu
Ymat
Ymat - mu
debugSource('~/MATLAB/Repositories/fdaM/glm.fda.R')
debugSource('~/MATLAB/Repositories/fdaM/glm.fda.R')
glmresult = glm.fda(basismat, y, 'normal', lamRmat)
di
mu - ymat
Ymat
Ymat - mu
(Ymat - mu)
(Ymat - mu)^2
debugSource('~/MATLAB/Repositories/fdaM/glm.fda.R')
debugSource('~/MATLAB/Repositories/fdaM/glm.fda.R')
glmresult = glm.fda(basismat, y, 'normal', lamRmat)
di
Deviance = sum((Wtvec %*% matrix(1,1,ncurve)) * di)
Deviance
print("hello")
printf("hello")
man print
put('h')
print
print("hello",1)
print("hello",2)
print("hello %i",2)
print("hello %i%",2)
printf <- function(...) cat(sprintf(...))
print("hello %d",2)
printf("hello %d",2)
source('~/MATLAB/Repositories/fdaM/glm.fda.R')
glmresult = glm.fda(basismat, y, 'normal', lamRmat)
source('~/MATLAB/Repositories/fdaM/glm.fda.R')
glmresult = glm.fda(basismat, y, 'normal', lamRmat)
source('~/MATLAB/Repositories/fdaM/glm.fda.R')
glmresult
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
fdobj = fd(coef,basisobj)
plotfit.fd(y, argvals, fdobj)
fdParobj = fdPar(basisobj, Lfdobj, lambda)
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
fdParCheck
fdParcheck
is.fdPar
is.fd
is.basis
fdPar
source("ycheck.R")
source("argcheck.R")
source("constrain.R")
source("fdParcheck.R")
source("glm.fda.R")
source("smooth.GLM.R")
debug("smooth.GLM.R")
debug("smooth.GLM")
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
source("ycheck.R")
source("argcheck.R")
source("constrain.R")
source("fdParcheck.R")
source("glm.fda.R")
source("smooth.GLM.R")
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
fdParobj = fdPar(basisobj, Lfdobj, lambda)
fdParobj
fdParcheck(fdParobj)
is.fd(fdParobj)
is.basis(fdParobj)
is.fd
fdPar
class(fdParobj)
inherits
inherits(fdParobj)
inherits(fdParobj,'fdPar')
inherits(fdParobj,'fd')
fdobj
fdobj
fdobj = fd(coef,basisobj)
plotfit.fd(y, argvals, fdobj)
fdParobj = fdPar(basisobj, Lfdobj, lambda)
fdobj = fd(coef,basisobj)
fdobj = fd(glmresult$coef,glmresult$basisobj)
plotfit.fd(y, argvals, fdobj)
fdParobj = fdPar(glmresult$basisobj, Lfdobj, lambda)
inherits(fdParobj,'fd')
fdParobj = fdPar(glmresult$basisobj, Lfdobj, lambda)
inherits(fdParobj,'fd')
fdPar
fdParobj = fdPar(fdobj, Lfdobj, lambda)
inherits(fdParobj,'fd')
inherits(fdobj,'fd')
oldClass
source('~/MATLAB/Repositories/fdaM/smooth.GLM.R')
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
debug(smooth.GLM)
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
source('~/MATLAB/Repositories/fdaM/smooth.GLM.R')
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
source('~/MATLAB/Repositories/fdaM/smooth.GLM.R')
debug("smooth.GLM")
smoothResult = smooth.GLM(argvals, y, fdParobj, 'family', 'normal')
source('~/MATLAB/Repositories/fdaM/smooth.GLM.R')
source('~/MATLAB/Repositories/fdaM/smooth.GLM.R')
